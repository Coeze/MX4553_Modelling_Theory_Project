import numpy as np
from src.model import CA

def apply_gap_strategy(model: CA, steps: int,
                       orientation: str = 'horizontal',
                       width: int = 3,
                       position: int = None) -> list:
    """
    Create a fuel-gap (firebreak) by lowering vegetation density
    along a straight line of given width.
    
    Parameters:
    - model: CA model
    - steps: total steps to run after creating the gap
    - orientation: 'horizontal' or 'vertical'
    - width: thickness of gap in cells
    - position: row (if horizontal) or col (if vertical) index
                at center of gap (defaults to mid-grid)
    
    Returns:
    - history: grid states at each time step
    """
    # pick center line if not specified
    if position is None:
        position = model.rows // 2 if orientation == 'horizontal' else model.cols // 2

    if orientation == 'horizontal':
        r0 = max(0, position - width // 2)
        r1 = min(model.rows, position + width // 2 + 1)
        for y in range(r0, r1):
            for x in range(model.cols):
                model.ndvi[y, x] = 0.05
                model.fuel_type[y, x] = 5
    else:
        c0 = max(0, position - width // 2)
        c1 = min(model.cols, position + width // 2 + 1)
        for y in range(model.rows):
            for x in range(c0, c1):
                model.ndvi[y, x] = 0.05
                model.fuel_type[y, x] = 5

    return model.run_simulation(steps, save_history=True)


def apply_nuke_strategy(model: CA, steps: int,
                        center: tuple = None,
                        radius: int = 10) -> list:
    """
    “Nuke” a circular area: instantly remove all fuel in radius.
    
    Parameters:
    - model: CA model
    - steps: total steps to run after clearing
    - center: (row, col) of blast center (defaults to grid center)
    - radius: blast radius in cells
    
    Returns:
    - history: grid states at each time step
    """
    # default to center of grid
    if center is None:
        center = (model.rows // 2, model.cols // 2)
    cy, cx = center

    for dy in range(-radius, radius + 1):
        for dx in range(-radius, radius + 1):
            y, x = cy + dy, cx + dx
            if 0 <= y < model.rows and 0 <= x < model.cols and dy**2 + dx**2 <= radius**2:
                model.ndvi[y, x] = 0.0
                model.fuel_type[y, x] = 0  # totally non-burnable

    return model.run_simulation(steps, save_history=True)


def apply_controlled_burn_strategy(model: CA, steps: int,
                                   patch_size: int = 10) -> list:
    """
    Controlled-burn a small square patch to consume fuel pre-emptively.
    
    Parameters:
    - model: CA model
    - steps: total steps to run after the burn
    - patch_size: side length of square pre-burn patch (cells)
    
    Returns:
    - history: grid states at each time step
    """
    # define a corner patch (you can choose any location)
    origin_y = (model.rows - patch_size) // 2
    origin_x = (model.cols - patch_size) // 2

    # ignite the patch
    for y in range(origin_y, origin_y + patch_size):
        for x in range(origin_x, origin_x + patch_size):
            model.grid[y, x] = 1  # burning state

    # let the patch burn itself out
    history = model.run_simulation(patch_size * 2, save_history=True)

    # clear burned cells permanently
    burned = (model.grid == 2)  # assuming 2 == burned
    model.ndvi[burned] = 0.0
    model.fuel_type[burned] = 0

    # now ignite main fire at center and run full simulation
    center = (model.rows // 2, model.cols // 2)
    model.grid[center] = 1
    history += model.run_simulation(steps, save_history=True)

    return history


# -*- coding: utf-8 -*-
"""
Wildfire Mitigation Framework

A comprehensive, modular Python package (~4000+ lines) for:
  - GIS data ingestion & preprocessing
  - Feature extraction (NDVI, slope, risk maps)
  - Cellular Automaton wildfire spread modeling
  - Diverse mitigation & intervention strategies
  - Parameter calibration (genetic algorithms)
  - Simulation orchestration & parameter sweeps
  - Advanced visualization (static, interactive, GIS overlays)
  - Metrics, reporting & logging

Copy-paste each section into separate modules as needed.
"""

# ==============================================================================
# SECTION 0: VERSION & METADATA
# ------------------------------------------------------------------------------
__version__ = '1.0.0'
__author__ = 'Your Name'
__email__  = 'youremail@example.com'

# ==============================================================================
# SECTION 1: DEPENDENCIES
# ------------------------------------------------------------------------------
import os
import logging
import numpy as np
import pandas as pd
import rasterio
from rasterio.features import rasterize
from rasterio.transform import from_origin
import geopandas as gpd
from shapely.geometry import mapping
from scipy.ndimage import convolve
import matplotlib.pyplot as plt
from matplotlib_scalebar.scalebar import ScaleBar
from matplotlib.animation import FuncAnimation
import fiona
import random
from deap import base, creator, tools, algorithms
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score
from sklearn.svm import SVC

# Set up logging
logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# ==============================================================================
# SECTION 2: CONFIGURATION & CONSTANTS
# ------------------------------------------------------------------------------
class Config:
    GRID_SIZE      = (200, 200)
    CELL_SIZE      = 30  # meters
    CA_PARAMS      = { 'c1': 0.5, 'c2': 0.5, 'p0': 0.6, 'p1': 0.3, 'p2': 0.1 }
    SPIRE_RADIUS   = 20  # for nuke strategy
    GAP_WIDTH      = 10  # cells
    BURN_PATCH     = 20  # side length
    SIM_STEPS      = 500
    GA_POPSIZE     = 50
    GA_GEN         = 40
    GA_CXPB        = 0.5
    GA_MUTPB       = 0.2
    DATA_DIR       = 'data/'

# ==============================================================================
# SECTION 3: UTILITY FUNCTIONS
# ------------------------------------------------------------------------------

def ensure_dir(path):
    """Create directory if it doesn't exist."""
    if not os.path.exists(path):
        os.makedirs(path)


def normalize(array, min_out=0.0, max_out=1.0):
    """Min-max normalize numpy array."""
    arr = np.array(array, dtype=float)
    mi, ma = np.nanmin(arr), np.nanmax(arr)
    if ma>mi:
        return (arr-mi)/(ma-mi)*(max_out-min_out) + min_out
    return np.full(arr.shape, (min_out+max_out)/2)

# ==============================================================================
# SECTION 4: DATA INGESTION & PREPROCESSING
# ------------------------------------------------------------------------------

def load_rasters(config, files: dict):
    """
    Load environmental rasters (slope, aspect, elevation, ndvi).
    files: {'slope': path, 'aspect': path, ...}
    Returns dict of arrays, transform, crs.
    """
    env = {}
    for key,path in files.items():
        with rasterio.open(path) as src:
            arr = src.read(1)
            transform, crs = src.transform, src.crs
        env[key] = normalize(arr)
        logger.info(f"Loaded {key} raster: {path}")
    return env, transform, crs


def load_fire_perimeter(path, shape, transform):
    """
    Rasterize shapefile to binary burned/non-burned mask.
    """
    gdf = gpd.read_file(path)
    shapes = ((geom,1) for geom in gdf.geometry)
    mask = rasterize(shapes, out_shape=shape,
                     transform=transform, fill=0, dtype=np.uint8)
    logger.info(f"Rasterized burn perimeter: {path}")
    return mask

# ... (more preprocessing: hotspot filtering, grid alignment)

# ==============================================================================
# SECTION 5: FEATURE EXTRACTION
# ------------------------------------------------------------------------------

def compute_risk_map(ndvi, slope, aspect, weights=None):
    """
    Combine NDVI, slope, aspect into risk index [0,1].
    weights: dict{'ndvi':w1,'slope':w2,'aspect':w3}
    """
    if weights is None:
        weights = {'ndvi':0.4, 'slope':0.4, 'aspect':0.2}
    norm_slope = normalize(slope)
    norm_aspect = normalize(aspect)
    risk = (weights['ndvi']*ndvi +
            weights['slope']*norm_slope +
            weights['aspect']*norm_aspect)
    return normalize(risk)

# ==============================================================================
# SECTION 6: CELLULAR AUTOMATON MODEL
# ------------------------------------------------------------------------------

class WildfireCA:
    """
    Cellular Automaton for wildfire spread.
    States: 0=unburnt,1=burning,2=burned.
    """
    def __init__(self, config: Config, env_features: dict):
        self.rows, self.cols = config.GRID_SIZE
        self.cell_size = config.CELL_SIZE
        self.params = config.CA_PARAMS.copy()
        # environmental arrays
        self.ndvi, self.slope, self.aspect = (
            env_features['ndvi'], env_features['slope'], env_features['aspect'])
        # fuel type randomly or from data
        self.fuel_type = np.random.randint(0,6,(self.rows,self.cols))
        self.grid = np.zeros((self.rows,self.cols),dtype=int)
        self.next_grid = np.zeros_like(self.grid)
        # dynamic conditions
        self.wind_speed = 5
        self.wind_dir = 0
        self.temperature = 30
        self.humidity = 20

    def set_fire_seeds(self, seeds): self.grid[tuple(zip(*seeds))] = 1
    
    def wind_effect(self):
        # simplified static factor
        return np.exp(self.wind_speed/10)
    
    def spread_probability(self, r,c):
        # combine NDVI, slope, wind, fuel_type model
        base = self.params['p0']*(1+self.ndvi[r,c])
        return min(1, base*self.wind_effect())

    def step(self):
        self.next_grid[:] = self.grid
        for r in range(self.rows):
            for c in range(self.cols):
                if self.grid[r,c]==1:
                    # burn out
                    self.next_grid[r,c]=2
                    # spread
                    for dr in (-1,0,1):
                        for dc in (-1,0,1):
                            nr, nc = r+dr, c+dc
                            if 0<=nr<self.rows and 0<=nc<self.cols and self.grid[nr,nc]==0:
                                if np.random.rand()<self.spread_probability(nr,nc):
                                    self.next_grid[nr,nc]=1
        self.grid, self.next_grid = self.next_grid, self.grid

    def run(self, max_steps):
        hist=[self.grid.copy()]
        for _ in range(max_steps):
            if not np.any(self.grid==1): break
            self.step()
            hist.append(self.grid.copy())
        return hist

# ==============================================================================
# SECTION 7: MITIGATION STRATEGIES
# ------------------------------------------------------------------------------

def strategy_firebreak(ca: WildfireCA, width: int):
    """Horizontal & vertical fuel break"""
    mid_r, mid_c = ca.rows//2, ca.cols//2
    ca.fuel_type[mid_r-width:mid_r+width,:] = 5
    ca.fuel_type[:,mid_c-width:mid_c+width] = 5

# … Add direct attack, point protection, backburn, drone-drop, vegetation-thinning

# ==============================================================================
# SECTION 8: CALIBRATION (GENETIC ALGORITHM)
# ------------------------------------------------------------------------------

def calibrate_params(ca_class, actual_mask, config):
    """
    Use DEAP to fit CA_PARAMS to match actual burn.
    """
    # DEAP setup
    creator.create('FitnessMin', base.Fitness, weights=(-1.0,))
    creator.create('Individual', list, fitness=creator.FitnessMin)
    toolbox = base.Toolbox()
    # parameter ranges
    param_ranges = [(0.1,1.0)]*len(config.CA_PARAMS)
    toolbox.register('attr_float', lambda low,high: random.uniform(low,high))
    # … complete GA workflow
    
# ==============================================================================
# SECTION 9: SIMULATION ORCHESTRATION
# ------------------------------------------------------------------------------

def run_experiments(config: Config, env_features: dict, actual_mask=None):
    """
    Coordinate multiple runs: baseline, each strategy, calibration.
    """
    results=[]
    ca0 = WildfireCA(config, env_features)
    ca0.set_fire_seeds([(config.GRID_SIZE[0]//2, config.GRID_SIZE[1]//2)])
    hist_baseline = ca0.run(config.SIM_STEPS)
    results.append(('baseline', hist_baseline))
    # apply each mitigation then run
    for strat in ['firebreak','nuke','controlled_burn']:
        ca = WildfireCA(config, env_features)
        ca.set_fire_seeds([(config.GRID_SIZE[0]//2, config.GRID_SIZE[1]//2)])
        if strat=='firebreak': strategy_firebreak(ca, config.GAP_WIDTH)
        # … other strategies
        hist = ca.run(config.SIM_STEPS)
        results.append((strat,hist))
    return results
    
# ==============================================================================
# SECTION 10: VISUALIZATION & REPORTING
# ------------------------------------------------------------------------------

def plot_comparison(results):
    """
    Multi-panel plot of fire spread for each strategy.
    """
    n = len(results)
    fig, axes = plt.subplots(1,n,figsize=(4*n,4))
    for ax,(name,hist) in zip(axes,results):
        ax.imshow(hist[-1], cmap='hot')
        ax.set_title(name)
        ax.axis('off')
    plt.tight_layout()
    return fig

# ==============================================================================
# SECTION 11: MAIN ENTRY POINT
# ------------------------------------------------------------------------------
if __name__ == '__main__':
    # Example workflow
    files = {
        'slope': os.path.join(Config.DATA_DIR,'slope.tif'),
        'aspect': os.path.join(Config.DATA_DIR,'aspect.tif'),
        'elevation': os.path.join(Config.DATA_DIR,'elev.tif'),
        'ndvi': os.path.join(Config.DATA_DIR,'ndvi.tif')
    }
    env_feats, transform, crs = load_rasters(Config, files)
    actual = load_fire_perimeter(os.path.join(Config.DATA_DIR,'perimeter.shp'),
                                 Config.GRID_SIZE, transform)
    results = run_experiments(Config, env_feats, actual)
    fig = plot_comparison(results)
    fig.savefig('comparison.png')
    logger.info('Simulation complete, output saved.')

