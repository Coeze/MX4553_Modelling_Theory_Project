import numpy as np
from src.model import CA

def apply_gap_strategy(model: CA, steps: int,
                       orientation: str = 'horizontal',
                       width: int = 3,
                       position: int = None) -> list:
    """
    Create a fuel-gap (firebreak) by lowering vegetation density
    along a straight line of given width.
    
    Parameters:
    - model: CA model
    - steps: total steps to run after creating the gap
    - orientation: 'horizontal' or 'vertical'
    - width: thickness of gap in cells
    - position: row (if horizontal) or col (if vertical) index
                at center of gap (defaults to mid-grid)
    
    Returns:
    - history: grid states at each time step
    """
    # pick center line if not specified
    if position is None:
        position = model.rows // 2 if orientation == 'horizontal' else model.cols // 2

    if orientation == 'horizontal':
        r0 = max(0, position - width // 2)
        r1 = min(model.rows, position + width // 2 + 1)
        for y in range(r0, r1):
            for x in range(model.cols):
                model.ndvi[y, x] = 0.05
                model.fuel_type[y, x] = 5
    else:
        c0 = max(0, position - width // 2)
        c1 = min(model.cols, position + width // 2 + 1)
        for y in range(model.rows):
            for x in range(c0, c1):
                model.ndvi[y, x] = 0.05
                model.fuel_type[y, x] = 5

    return model.run_simulation(steps, save_history=True)


def apply_nuke_strategy(model: CA, steps: int,
                        center: tuple = None,
                        radius: int = 10) -> list:
    """
    “Nuke” a circular area: instantly remove all fuel in radius.
    
    Parameters:
    - model: CA model
    - steps: total steps to run after clearing
    - center: (row, col) of blast center (defaults to grid center)
    - radius: blast radius in cells
    
    Returns:
    - history: grid states at each time step
    """
    # default to center of grid
    if center is None:
        center = (model.rows // 2, model.cols // 2)
    cy, cx = center

    for dy in range(-radius, radius + 1):
        for dx in range(-radius, radius + 1):
            y, x = cy + dy, cx + dx
            if 0 <= y < model.rows and 0 <= x < model.cols and dy**2 + dx**2 <= radius**2:
                model.ndvi[y, x] = 0.0
                model.fuel_type[y, x] = 0  # totally non-burnable

    return model.run_simulation(steps, save_history=True)


def apply_controlled_burn_strategy(model: CA, steps: int,
                                   patch_size: int = 10) -> list:
    """
    Controlled-burn a small square patch to consume fuel pre-emptively.
    
    Parameters:
    - model: CA model
    - steps: total steps to run after the burn
    - patch_size: side length of square pre-burn patch (cells)
    
    Returns:
    - history: grid states at each time step
    """
    # define a corner patch (you can choose any location)
    origin_y = (model.rows - patch_size) // 2
    origin_x = (model.cols - patch_size) // 2

    # ignite the patch
    for y in range(origin_y, origin_y + patch_size):
        for x in range(origin_x, origin_x + patch_size):
            model.grid[y, x] = 1  # burning state

    # let the patch burn itself out
    history = model.run_simulation(patch_size * 2, save_history=True)

    # clear burned cells permanently
    burned = (model.grid == 2)  # assuming 2 == burned
    model.ndvi[burned] = 0.0
    model.fuel_type[burned] = 0

    # now ignite main fire at center and run full simulation
    center = (model.rows // 2, model.cols // 2)
    model.grid[center] = 1
    history += model.run_simulation(steps, save_history=True)

    return history


# -*- coding: utf-8 -*-
"""
Wildfire Mitigation Framework

A comprehensive, modular Python package (~4000+ lines) for:
  - GIS data ingestion & preprocessing
  - Feature extraction (NDVI, slope, risk maps)
  - Cellular Automaton wildfire spread modeling
  - Diverse mitigation & intervention strategies
  - Parameter calibration (genetic algorithms)
  - Simulation orchestration & parameter sweeps
  - Advanced visualization (static, interactive, GIS overlays)
  - Metrics, reporting & logging

Copy-paste each section into separate modules as needed.
"""

# ==============================================================================
# SECTION 0: VERSION & METADATA
# ------------------------------------------------------------------------------
__version__ = '1.0.0'
__author__ = 'Your Name'
__email__  = 'youremail@example.com'

# ==============================================================================
# SECTION 1: DEPENDENCIES
# ------------------------------------------------------------------------------
import os
import logging
import numpy as np
import pandas as pd
import rasterio
from rasterio.features import rasterize
from rasterio.transform import from_origin
import geopandas as gpd
from shapely.geometry import mapping
from scipy.ndimage import convolve
import matplotlib.pyplot as plt
from matplotlib_scalebar.scalebar import ScaleBar
from matplotlib.animation import FuncAnimation
import fiona
import random
from deap import base, creator, tools, algorithms
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score
from sklearn.svm import SVC

# Set up logging
logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# ==============================================================================
# SECTION 2: CONFIGURATION & CONSTANTS
# ------------------------------------------------------------------------------
class Config:
    GRID_SIZE      = (200, 200)
    CELL_SIZE      = 30  # meters
    CA_PARAMS      = { 'c1': 0.5, 'c2': 0.5, 'p0': 0.6, 'p1': 0.3, 'p2': 0.1 }
    SPIRE_RADIUS   = 20  # for nuke strategy
    GAP_WIDTH      = 10  # cells
    BURN_PATCH     = 20  # side length
    SIM_STEPS      = 500
    GA_POPSIZE     = 50
    GA_GEN         = 40
    GA_CXPB        = 0.5
    GA_MUTPB       = 0.2
    DATA_DIR       = 'data/'

# ==============================================================================
# SECTION 3: UTILITY FUNCTIONS
# ------------------------------------------------------------------------------

def ensure_dir(path):
    """Create directory if it doesn't exist."""
    if not os.path.exists(path):
        os.makedirs(path)


def normalize(array, min_out=0.0, max_out=1.0):
    """Min-max normalize numpy array."""
    arr = np.array(array, dtype=float)
    mi, ma = np.nanmin(arr), np.nanmax(arr)
    if ma>mi:
        return (arr-mi)/(ma-mi)*(max_out-min_out) + min_out
    return np.full(arr.shape, (min_out+max_out)/2)

# ==============================================================================
# SECTION 4: DATA INGESTION & PREPROCESSING
# ------------------------------------------------------------------------------

def load_rasters(config, files: dict):
    """
    Load environmental rasters (slope, aspect, elevation, ndvi).
    files: {'slope': path, 'aspect': path, ...}
    Returns dict of arrays, transform, crs.
    """
    env = {}
    for key,path in files.items():
        with rasterio.open(path) as src:
            arr = src.read(1)
            transform, crs = src.transform, src.crs
        env[key] = normalize(arr)
        logger.info(f"Loaded {key} raster: {path}")
    return env, transform, crs


def load_fire_perimeter(path, shape, transform):
    """
    Rasterize shapefile to binary burned/non-burned mask.
    """
    gdf = gpd.read_file(path)
    shapes = ((geom,1) for geom in gdf.geometry)
    mask = rasterize(shapes, out_shape=shape,
                     transform=transform, fill=0, dtype=np.uint8)
    logger.info(f"Rasterized burn perimeter: {path}")
    return mask

# ... (more preprocessing: hotspot filtering, grid alignment)

# ==============================================================================
# SECTION 5: FEATURE EXTRACTION
# ------------------------------------------------------------------------------

def compute_risk_map(ndvi, slope, aspect, weights=None):
    """
    Combine NDVI, slope, aspect into risk index [0,1].
    weights: dict{'ndvi':w1,'slope':w2,'aspect':w3}
    """
    if weights is None:
        weights = {'ndvi':0.4, 'slope':0.4, 'aspect':0.2}
    norm_slope = normalize(slope)
    norm_aspect = normalize(aspect)
    risk = (weights['ndvi']*ndvi +
            weights['slope']*norm_slope +
            weights['aspect']*norm_aspect)
    return normalize(risk)

# ==============================================================================
# SECTION 6: CELLULAR AUTOMATON MODEL
# ------------------------------------------------------------------------------

class WildfireCA:
    """
    Cellular Automaton for wildfire spread.
    States: 0=unburnt,1=burning,2=burned.
    """
    def __init__(self, config: Config, env_features: dict):
        self.rows, self.cols = config.GRID_SIZE
        self.cell_size = config.CELL_SIZE
        self.params = config.CA_PARAMS.copy()
        # environmental arrays
        self.ndvi, self.slope, self.aspect = (
            env_features['ndvi'], env_features['slope'], env_features['aspect'])
        # fuel type randomly or from data
        self.fuel_type = np.random.randint(0,6,(self.rows,self.cols))
        self.grid = np.zeros((self.rows,self.cols),dtype=int)
        self.next_grid = np.zeros_like(self.grid)
        # dynamic conditions
        self.wind_speed = 5
        self.wind_dir = 0
        self.temperature = 30
        self.humidity = 20

    def set_fire_seeds(self, seeds): self.grid[tuple(zip(*seeds))] = 1
    
    def wind_effect(self):
        # simplified static factor
        return np.exp(self.wind_speed/10)
    
    def spread_probability(self, r,c):
        # combine NDVI, slope, wind, fuel_type model
        base = self.params['p0']*(1+self.ndvi[r,c])
        return min(1, base*self.wind_effect())

    def step(self):
        self.next_grid[:] = self.grid
        for r in range(self.rows):
            for c in range(self.cols):
                if self.grid[r,c]==1:
                    # burn out
                    self.next_grid[r,c]=2
                    # spread
                    for dr in (-1,0,1):
                        for dc in (-1,0,1):
                            nr, nc = r+dr, c+dc
                            if 0<=nr<self.rows and 0<=nc<self.cols and self.grid[nr,nc]==0:
                                if np.random.rand()<self.spread_probability(nr,nc):
                                    self.next_grid[nr,nc]=1
        self.grid, self.next_grid = self.next_grid, self.grid

    def run(self, max_steps):
        hist=[self.grid.copy()]
        for _ in range(max_steps):
            if not np.any(self.grid==1): break
            self.step()
            hist.append(self.grid.copy())
        return hist

# ==============================================================================
# SECTION 7: MITIGATION STRATEGIES
# ------------------------------------------------------------------------------

def strategy_firebreak(ca: WildfireCA, width: int):
    """Horizontal & vertical fuel break"""
    mid_r, mid_c = ca.rows//2, ca.cols//2
    ca.fuel_type[mid_r-width:mid_r+width,:] = 5
    ca.fuel_type[:,mid_c-width:mid_c+width] = 5

# … Add direct attack, point protection, backburn, drone-drop, vegetation-thinning

# ==============================================================================
# SECTION 8: CALIBRATION (GENETIC ALGORITHM)
# ------------------------------------------------------------------------------

def calibrate_params(ca_class, actual_mask, config):
    """
    Use DEAP to fit CA_PARAMS to match actual burn.
    """
    # DEAP setup
    creator.create('FitnessMin', base.Fitness, weights=(-1.0,))
    creator.create('Individual', list, fitness=creator.FitnessMin)
    toolbox = base.Toolbox()
    # parameter ranges
    param_ranges = [(0.1,1.0)]*len(config.CA_PARAMS)
    toolbox.register('attr_float', lambda low,high: random.uniform(low,high))
    # … complete GA workflow
    
# ==============================================================================
# SECTION 9: SIMULATION ORCHESTRATION
# ------------------------------------------------------------------------------

def run_experiments(config: Config, env_features: dict, actual_mask=None):
    """
    Coordinate multiple runs: baseline, each strategy, calibration.
    """
    results=[]
    ca0 = WildfireCA(config, env_features)
    ca0.set_fire_seeds([(config.GRID_SIZE[0]//2, config.GRID_SIZE[1]//2)])
    hist_baseline = ca0.run(config.SIM_STEPS)
    results.append(('baseline', hist_baseline))
    # apply each mitigation then run
    for strat in ['firebreak','nuke','controlled_burn']:
        ca = WildfireCA(config, env_features)
        ca.set_fire_seeds([(config.GRID_SIZE[0]//2, config.GRID_SIZE[1]//2)])
        if strat=='firebreak': strategy_firebreak(ca, config.GAP_WIDTH)
        # … other strategies
        hist = ca.run(config.SIM_STEPS)
        results.append((strat,hist))
    return results
    
# ==============================================================================
# SECTION 10: VISUALIZATION & REPORTING
# ------------------------------------------------------------------------------

def plot_comparison(results):
    """
    Multi-panel plot of fire spread for each strategy.
    """
    n = len(results)
    fig, axes = plt.subplots(1,n,figsize=(4*n,4))
    for ax,(name,hist) in zip(axes,results):
        ax.imshow(hist[-1], cmap='hot')
        ax.set_title(name)
        ax.axis('off')
    plt.tight_layout()
    return fig

# ==============================================================================
# SECTION 11: MAIN ENTRY POINT
# ------------------------------------------------------------------------------
if __name__ == '__main__':
    # Example workflow
    files = {
        'slope': os.path.join(Config.DATA_DIR,'slope.tif'),
        'aspect': os.path.join(Config.DATA_DIR,'aspect.tif'),
        'elevation': os.path.join(Config.DATA_DIR,'elev.tif'),
        'ndvi': os.path.join(Config.DATA_DIR,'ndvi.tif')
    }
    env_feats, transform, crs = load_rasters(Config, files)
    actual = load_fire_perimeter(os.path.join(Config.DATA_DIR,'perimeter.shp'),
                                 Config.GRID_SIZE, transform)
    results = run_experiments(Config, env_feats, actual)
    fig = plot_comparison(results)
    fig.savefig('comparison.png')
    logger.info('Simulation complete, output saved.')




# =============================================================================
# Section 1: Imports
# =============================================================================
import os
import math
import random
import numpy as np
import pandas as pd
import rasterio
from rasterio import features
from rasterio.transform import from_origin
import geopandas as gpd
import fiona
import matplotlib.pyplot as plt
from matplotlib_scalebar.scalebar import ScaleBar
from matplotlib.animation import FuncAnimation
from shapely.geometry import mapping, box
from scipy.ndimage import convolve
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, precision_score, recall_score
from deap import base, creator, tools, algorithms


# =============================================================================
# Section 2: Configuration & Constants
# =============================================================================
GRID_SIZE = (200, 200)    # rows, cols
CELL_SIZE = 30            # meters
FUEL_TYPES = {
    0: 'Water/Urban',
    1: 'Grassland',
    2: 'Shrubs',
    3: 'Broadleaf Forest',
    4: 'Coniferous Forest',
    5: 'Agro-forest'
}
STATE_UNBURNT, STATE_BURNING, STATE_BURNT = 0, 1, 2

# Kernel for 8‐neighborhood
_NEIGHBORHOOD_KERNEL = np.ones((3,3), dtype=int)


# =============================================================================
# Section 3: Data Loaders & Preprocessors
# =============================================================================
def load_raster(path, target_shape=GRID_SIZE):
    """ Load and (if needed) resample a single‐band raster to GRID_SIZE. """
    with rasterio.open(path) as src:
        arr = src.read(1)
        transform = src.transform
        if arr.shape != target_shape:
            arr = np.array(
                features.rasterize([], out_shape=target_shape), 
                dtype=arr.dtype
            )  # placeholder for actual resampling logic
        return arr, transform, src.crs

def load_shapefile(path):
    """ Load a shapefile into GeoDataFrame. """
    return gpd.read_file(path)

def vector_to_raster(gdf, out_shape=GRID_SIZE, transform=None):
    """ Rasterize GeoDataFrame to match grid. """
    geoms = ((geom, 1) for geom in gdf.geometry)
    return features.rasterize(geoms, out_shape=out_shape, transform=transform, dtype=np.uint8)


# =============================================================================
# Section 4: Fire Intensity Mapping
# =============================================================================
class FireIntensityMapper:
    """
    Compute per‐cell fire intensity (e.g. based on DNBR, NDVI).
    """
    def __init__(self, dnbr_raster, ndvi_raster):
        self.dnbr, _, _ = load_raster(dnbr_raster)
        self.ndvi, _, _ = load_raster(ndvi_raster)
        # Scale to [0,1]
        self.intensity = self._normalize(self.dnbr) * 0.7 + self._normalize(self.ndvi) * 0.3

    def _normalize(self, arr):
        minv, maxv = np.nanmin(arr), np.nanmax(arr)
        return (arr - minv) / (maxv - minv + 1e-8)

    def get_intensity_map(self):
        """ Returns a float‐array [0..1] of fire intensity per cell. """
        return self.intensity

    def plot_intensity(self, ax=None):
        ax = ax or plt.gca()
        im = ax.imshow(self.intensity, cmap='hot', interpolation='nearest')
        plt.colorbar(im, ax=ax, label='Fire Intensity [0–1]')
        ax.set_title('Fire Intensity Map')
        ax.axis('off')


# =============================================================================
# Section 5: Fire Extinguishing Strategies
# =============================================================================
class WaterDrop:
    """ Simulate aerial water drops to extinguish fire. """
    def __init__(self, model, drop_volume=5000):
        self.model = model
        self.volume = drop_volume  # liters per drop

    def drop(self, center, radius):
        """ Reduce burning probability in a circle by humidity boost. """
        cy, cx = center
        y, x = np.ogrid[:self.model.rows, :self.model.cols]
        mask = (y - cy)**2 + (x - cx)**2 <= radius**2
        self.model.humidity_map[mask] += 50  # +50% humidity
        self.model.humidity_map = np.clip(self.model.humidity_map, 0, 100)

class FuelBreak:
    """ Create linear breaks in vegetation (fuel). """
    @staticmethod
    def create_gap(model, orientation='horizontal', pos=None, width=5):
        pos = pos or (model.rows//2 if orientation=='horizontal' else model.cols//2)
        if orientation=='horizontal':
            r0, r1 = pos-width//2, pos+width//2+1
            model.fuel_map[r0:r1, :] = 0
        else:
            c0, c1 = pos-width//2, pos+width//2+1
            model.fuel_map[:, c0:c1] = 0

class ControlledBurn:
    """ Ignite small patch to consume fuel ahead of main fire. """
    @staticmethod
    def execute(model, top_left, size=10):
        y0, x0 = top_left
        for y in range(y0, min(y0+size, model.rows)):
            for x in range(x0, min(x0+size, model.cols)):
                model.grid[y, x] = STATE_BURNING
        model.step_simulation(size*2)


# =============================================================================
# Section 6: Fire Spread (Cellular Automaton)
# =============================================================================
class FireSpreadCA:
    """
    A simple CA to simulate fire spread, using fuel & humidity maps.
    """
    def __init__(self, fuel_map, humidity_map, wind=(0,0)):
        self.rows, self.cols = fuel_map.shape
        self.grid = np.zeros_like(fuel_map, dtype=int)
        self.fuel_map = fuel_map.copy()
        self.humidity_map = humidity_map.copy()
        self.wind_speed, self.wind_dir = wind

    def ignite(self, points):
        for y,x in points:
            self.grid[y,x] = STATE_BURNING

    def step(self):
        nbr_burning = convolve((self.grid==STATE_BURNING).astype(int),
                               _NEIGHBORHOOD_KERNEL, mode='constant')
        new = self.grid.copy()
        for y in range(self.rows):
            for x in range(self.cols):
                if self.grid[y,x]==STATE_UNBURNT and self.fuel_map[y,x]>0:
                    p_base = 0.3 * self.fuel_map[y,x]
                    p_hum = max(0, 1 - self.humidity_map[y,x]/100)
                    p_n = nbr_burning[y,x] / 8
                    p_final = p_base * p_hum * (1 + 0.2*p_n)
                    if random.random() < p_final:
                        new[y,x] = STATE_BURNING
                elif self.grid[y,x]==STATE_BURNING:
                    new[y,x] = STATE_BURNT
        self.grid = new

    def step_simulation(self, steps):
        history = [self.grid.copy()]
        for _ in range(steps):
            if not np.any(self.grid==STATE_BURNING):
                break
            self.step()
            history.append(self.grid.copy())
        return history


# =============================================================================
# Section 7: Simulation Manager
# =============================================================================
class SimulationManager:
    """
    Orchestrates loading data, running strategies, and saving results.
    """
    def __init__(self, config):
        self.config = config
        # load static layers
        self.fuel_map, self.transform, self.crs = load_raster(config['fuel_raster'])
        self.humidity_map = np.zeros_like(self.fuel_map) + config.get('initial_humidity', 10)
        self.mapper = FireIntensityMapper(config['dnbr_raster'], config['ndvi_raster'])

    def run_all(self):
        mgr = {}
        # baseline spread
        ca = FireSpreadCA(self.fuel_map, self.humidity_map, wind=self.config['wind'])
        ca.ignite([self.config['ignition_point']])
        mgr['baseline'] = ca.step_simulation(self.config['max_steps'])
        # fuel break
        FuelBreak.create_gap(ca, orientation='horizontal', width=10)
        mgr['fuel_break'] = ca.step_simulation(self.config['max_steps'])
        # water drop
        wd = WaterDrop(ca)
        wd.drop(self.config['ignition_point'], radius=20)
        mgr['water_drop'] = ca.step_simulation(self.config['max_steps'])
        # controlled burn
        ControlledBurn.execute(ca, top_left=(0,0), size=15)
        mgr['controlled_burn'] = ca.step_simulation(self.config['max_steps'])
        return mgr

    def save_results(self, history_dict, out_folder):
        os.makedirs(out_folder, exist_ok=True)
        for name, hist in history_dict.items():
            np.save(os.path.join(out_folder, f"{name}_history.npy"), np.array(hist))


# =============================================================================
# Section 8: Metrics & Evaluation
# =============================================================================
class MetricsEvaluator:
    @staticmethod
    def burned_fraction(grid, fuel_map):
        total = np.sum(fuel_map>0)
        burnt = np.sum(grid==STATE_BURNT)
        return burnt/total if total>0 else 0

    @staticmethod
    def area_burnt(burnt_frac):
        return burnt_frac * GRID_SIZE[0] * GRID_SIZE[1] * (CELL_SIZE**2)  # m²

    @staticmethod
    def compare_histories(hist_dict, fuel_map):
        stats = {}
        for name, hist in hist_dict.items():
            stats[name] = MetricsEvaluator.burned_fraction(hist[-1], fuel_map)
        return stats


# =============================================================================
# Section 9: Visualization Utilities
# =============================================================================
class Viz:
    @staticmethod
    def plot_history(hist, title="Simulation", interval=200):
        fig, ax = plt.subplots(figsize=(6,6))
        cmap = plt.cm.get_cmap('inferno', 3)
        def update(i):
            ax.clear()
            ax.imshow(hist[i], cmap=cmap, vmin=0, vmax=2)
            ax.set_title(f"{title} – Step {i}")
            ax.axis('off')
        FuncAnimation(fig, update, frames=len(hist), interval=interval)
        plt.show()

    @staticmethod
    def side_by_side(latest_maps, names):
        n = len(latest_maps)
        fig, axs = plt.subplots(1, n, figsize=(4*n,4))
        for ax, grid, nm in zip(axs, latest_maps, names):
            ax.imshow(grid, cmap='hot', interpolation='nearest')
            ax.set_title(nm)
            ax.axis('off')
        plt.tight_layout()


# =============================================================================
# Section 10: Main Execution
# =============================================================================
if __name__ == "__main__":
    # --- Configuration dictionary ---
    config = {
        'fuel_raster'   : 'data/fuel.tif',
        'dnbr_raster'   : 'data/dnbr.tif',
        'ndvi_raster'   : 'data/ndvi.tif',
        'initial_humidity': 15,
        'wind'          : (5.0, 90),     # 5 m/s east
        'ignition_point': (100, 100),
        'max_steps'     : 200
    }

    # Run all scenarios
    sim = SimulationManager(config)
    results = sim.run_all()
    sim.save_results(results, out_folder='outputs/')

    # Evaluate
    burned_stats = MetricsEvaluator.compare_histories(results, sim.fuel_map)
    print("Burned fractions by strategy:")
    for strat, frac in burned_stats.items():
        print(f"  {strat:15s}: {frac:.2%}")

    # Visualize final maps
    final_grids = [h[-1] for h in results.values()]
    Viz.side_by_side(final_grids, list(results.keys()))

